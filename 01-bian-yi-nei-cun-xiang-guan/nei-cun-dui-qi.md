---
description: 面试高频指数：★★☆☆☆
---

# 内存对齐

### 什么是内存对齐?

内存对齐：编译器将程序中的每个“数据单元”安排在字的整数倍的地址指向的内存之中

### 内存对齐规则

* 结构体变量的首地址能够被其最宽基本类型成员大小与对齐基数中的较小者所整除；
* 结构体每个成员相对于结构体首地址的偏移量 （offset） 都是该成员大小与对齐基数中的较小者的整数倍，如有需要编译器会在成员之间加上填充字节 （internal padding）； 
* 结构体的总大小为结构体最宽基本类型成员大小与对齐基数中的较小者的整数倍，如有需要编译器会在最末一个成员之后加上填充字节 （trailing padding）。

![&#x56FE;1. &#x5185;&#x5B58;&#x5BF9;&#x9F50;](../.gitbook/assets/image%20%282%29.png)

```cpp
// 程序在64位系统当中测试
#include <iostream>                                                             

struct MemoryTest{
    int a;    // 4个字节
    float b;  // 4 + 4 = 8字节
    double c; // 8 + 8 = 16字节
    char d;   //16 + 1 = 17字节
}; //17 + 7(对齐) = 24字节


int main(int argc, char *argv[])
{
    std::cout << "sizeof(MemoryTest): " \
        << sizeof(MemoryTest) << std::endl; // 24
    return 0;
}
```

### 内存对齐的原因:

1. 某些硬件设备只能存取对齐数据，存取非对齐的数据可能会引发异常
2. 某些硬件设备不能保证在存取非对齐数据的时候的操作是原子操作
3. 相比于存取对齐的数据，存取非对齐的数据需要花费更多的时间
4. 某些处理器虽然支持非对齐数据的访问，但会引发对齐陷阱（alignment trap）
5. 某些硬件设备只支持简单数据指令非对齐存取，不支持复杂数据指令的非对齐存取

### 内存对齐的优点

1. **方便移植**: 有些平台不支持内存随机存储，强行读取会抛出异常
2. **提高内存访问速度**: 因为CPU从内存中读取数据是一块一块进行读取的，如果内存不对齐则需要两步操作才能访问到所需数据 

